-- ============================================================================
-- KINESSIA HUB - SCRIPT DE MIGRACIÓN COMPLETA
-- ============================================================================
-- Versión: 1.0
-- Fecha: 2025-01-XX
-- Descripción: Migración para cumplir con requerimientos RF-01 a RF-11 y RNF-01 a RNF-05
-- ============================================================================

-- ============================================================================
-- PARTE 1: NUEVAS TABLAS BASE
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 1.1 SUCURSALES (Para segregación Ensenada/Mexicali - RNF-02)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.sucursales (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre TEXT NOT NULL UNIQUE,
    ciudad TEXT NOT NULL,
    direccion TEXT,
    telefono TEXT,
    activa BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.sucursales IS 'Catálogo de sucursales para segregación de datos (Ensenada/Mexicali)';

-- Insertar sucursales iniciales
INSERT INTO public.sucursales (nombre, ciudad) VALUES 
    ('Ensenada', 'Ensenada'),
    ('Mexicali', 'Mexicali')
ON CONFLICT (nombre) DO NOTHING;

-- ----------------------------------------------------------------------------
-- 1.2 TARJETAS CORPORATIVAS (Para control de papeletas - RF-06)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.tarjetas_corporativas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    numero_tarjeta TEXT NOT NULL UNIQUE, -- Últimos 4 dígitos o identificador interno
    nombre_tarjeta TEXT NOT NULL, -- Ej: "AMEX Corporativa 001", "Visa Empresarial"
    banco TEXT,
    titular TEXT, -- Nombre del titular
    limite_credito NUMERIC(12,2) DEFAULT 0,
    fecha_corte INTEGER, -- Día del mes (1-31)
    fecha_pago INTEGER, -- Día del mes (1-31)
    sucursal_id BIGINT REFERENCES public.sucursales(id),
    activa BOOLEAN NOT NULL DEFAULT true,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.tarjetas_corporativas IS 'Catálogo de tarjetas de crédito corporativas para papeletas';
COMMENT ON COLUMN public.tarjetas_corporativas.numero_tarjeta IS 'Identificador único de la tarjeta (últimos 4 dígitos o código interno)';

-- ----------------------------------------------------------------------------
-- 1.3 AUTORIZACIONES (Sistema de excepciones - RF-09)
-- ----------------------------------------------------------------------------
CREATE TYPE public.estatus_autorizacion AS ENUM ('pendiente', 'aprobada', 'rechazada', 'expirada');
CREATE TYPE public.tipo_autorizacion AS ENUM ('uso_tarjeta', 'exceso_credito', 'descuento_especial', 'otro');

CREATE TABLE IF NOT EXISTS public.autorizaciones (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    tipo tipo_autorizacion NOT NULL,
    solicitante_id BIGINT NOT NULL REFERENCES public.usuarios(id),
    autorizador_id BIGINT REFERENCES public.usuarios(id), -- NULL si está pendiente
    
    -- Referencias opcionales según el tipo
    tarjeta_id BIGINT REFERENCES public.tarjetas_corporativas(id),
    empresa_id BIGINT REFERENCES public.empresas(id),
    desglose_folio BIGINT REFERENCES public.desgloses(folio),
    
    motivo TEXT NOT NULL,
    monto_solicitado NUMERIC(12,2), -- Para excesos de crédito
    estatus estatus_autorizacion NOT NULL DEFAULT 'pendiente',
    
    fecha_solicitud TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    fecha_respuesta TIMESTAMPTZ,
    comentario_respuesta TEXT,
    
    -- Para notificaciones
    notificado_google_chat BOOLEAN DEFAULT false,
    
    sucursal_id BIGINT NOT NULL REFERENCES public.sucursales(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.autorizaciones IS 'Registro de solicitudes de autorización especial (RF-09)';

-- Índice para búsquedas frecuentes
CREATE INDEX idx_autorizaciones_estatus ON public.autorizaciones(estatus) WHERE estatus = 'pendiente';
CREATE INDEX idx_autorizaciones_solicitante ON public.autorizaciones(solicitante_id);

-- ----------------------------------------------------------------------------
-- 1.4 COMPROBANTES DE PAGO (RF-10)
-- ----------------------------------------------------------------------------
CREATE TYPE public.tipo_comprobante AS ENUM ('transferencia', 'deposito', 'cheque', 'otro');

CREATE TABLE IF NOT EXISTS public.comprobantes_pago (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    -- Puede estar ligado a un desglose o a una papeleta
    desglose_folio BIGINT REFERENCES public.desgloses(folio),
    papeleta_id BIGINT REFERENCES public.papeletas(id),
    empresa_id BIGINT REFERENCES public.empresas(id),
    
    tipo tipo_comprobante NOT NULL,
    archivo_url TEXT NOT NULL, -- URL en Supabase Storage
    archivo_nombre TEXT NOT NULL,
    monto NUMERIC(12,2) NOT NULL,
    fecha_pago DATE NOT NULL,
    referencia TEXT, -- Número de referencia bancaria
    
    -- Quién subió el comprobante
    usuario_id BIGINT NOT NULL REFERENCES public.usuarios(id),
    
    -- Notificación al agente de ventas
    agente_notificado BOOLEAN DEFAULT false,
    fecha_notificacion TIMESTAMPTZ,
    
    sucursal_id BIGINT NOT NULL REFERENCES public.sucursales(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    
    -- Al menos debe tener un desglose o papeleta asociado
    CONSTRAINT chk_comprobante_referencia CHECK (
        desglose_folio IS NOT NULL OR papeleta_id IS NOT NULL
    )
);

COMMENT ON TABLE public.comprobantes_pago IS 'Comprobantes de pago adjuntos (PDFs de transferencias) - RF-10';

-- ----------------------------------------------------------------------------
-- 1.5 CRÉDITOS Y MOVIMIENTOS (RF-08)
-- ----------------------------------------------------------------------------
CREATE TYPE public.tipo_movimiento_credito AS ENUM ('cargo', 'abono', 'ajuste', 'inicial');

CREATE TABLE IF NOT EXISTS public.creditos_movimientos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    empresa_id BIGINT NOT NULL REFERENCES public.empresas(id),
    
    tipo tipo_movimiento_credito NOT NULL,
    monto NUMERIC(12,2) NOT NULL,
    saldo_anterior NUMERIC(12,2) NOT NULL,
    saldo_nuevo NUMERIC(12,2) NOT NULL,
    
    -- Referencia al documento que generó el movimiento
    desglose_folio BIGINT REFERENCES public.desgloses(folio),
    comprobante_id BIGINT REFERENCES public.comprobantes_pago(id),
    
    concepto TEXT NOT NULL,
    usuario_id BIGINT NOT NULL REFERENCES public.usuarios(id),
    
    sucursal_id BIGINT NOT NULL REFERENCES public.sucursales(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.creditos_movimientos IS 'Historial de movimientos de crédito por empresa - RF-08';

CREATE INDEX idx_creditos_empresa ON public.creditos_movimientos(empresa_id);
CREATE INDEX idx_creditos_fecha ON public.creditos_movimientos(created_at DESC);

-- ----------------------------------------------------------------------------
-- 1.6 AUDIT LOGS (RF-03)
-- ----------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS public.audit_logs (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    tabla_nombre TEXT NOT NULL,
    registro_id TEXT NOT NULL, -- ID del registro afectado (como TEXT para flexibilidad)
    accion TEXT NOT NULL CHECK (accion IN ('INSERT', 'UPDATE', 'DELETE')),
    
    datos_anteriores JSONB, -- NULL para INSERT
    datos_nuevos JSONB, -- NULL para DELETE
    campos_modificados TEXT[], -- Lista de campos que cambiaron
    
    usuario_id BIGINT REFERENCES public.usuarios(id),
    usuario_email TEXT, -- Respaldo por si el usuario se elimina
    ip_address INET,
    user_agent TEXT,
    
    sucursal_id BIGINT REFERENCES public.sucursales(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.audit_logs IS 'Registro de auditoría de todas las acciones del sistema - RF-03';

CREATE INDEX idx_audit_tabla ON public.audit_logs(tabla_nombre, created_at DESC);
CREATE INDEX idx_audit_usuario ON public.audit_logs(usuario_id);
CREATE INDEX idx_audit_fecha ON public.audit_logs(created_at DESC);

-- ----------------------------------------------------------------------------
-- 1.7 NOTIFICACIONES (Para webhooks a Google Chat - RNF-04)
-- ----------------------------------------------------------------------------
CREATE TYPE public.tipo_notificacion AS ENUM (
    'autorizacion_solicitada', 
    'autorizacion_respondida',
    'tiempo_limite_pago',
    'comprobante_adjuntado',
    'credito_excedido',
    'otro'
);
CREATE TYPE public.estatus_notificacion AS ENUM ('pendiente', 'enviada', 'fallida');

CREATE TABLE IF NOT EXISTS public.notificaciones (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    
    tipo tipo_notificacion NOT NULL,
    destinatario TEXT NOT NULL, -- Email o ID de Google Chat
    canal TEXT NOT NULL DEFAULT 'google_chat', -- 'google_chat', 'email', etc.
    
    titulo TEXT NOT NULL,
    mensaje TEXT NOT NULL,
    payload JSONB, -- Datos adicionales para el webhook
    
    -- Referencias opcionales
    autorizacion_id BIGINT REFERENCES public.autorizaciones(id),
    desglose_folio BIGINT REFERENCES public.desgloses(folio),
    empresa_id BIGINT REFERENCES public.empresas(id),
    
    estatus estatus_notificacion NOT NULL DEFAULT 'pendiente',
    intentos INTEGER DEFAULT 0,
    ultimo_error TEXT,
    
    fecha_programada TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    fecha_enviada TIMESTAMPTZ,
    
    sucursal_id BIGINT REFERENCES public.sucursales(id),
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

COMMENT ON TABLE public.notificaciones IS 'Cola de notificaciones para webhooks - RNF-04';

CREATE INDEX idx_notificaciones_pendientes ON public.notificaciones(estatus, fecha_programada) 
    WHERE estatus = 'pendiente';


-- ============================================================================
-- PARTE 2: MODIFICACIONES A TABLAS EXISTENTES
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 2.1 MODIFICAR TABLA USUARIOS (RF-01)
-- ----------------------------------------------------------------------------
-- Agregar sucursal_id
ALTER TABLE public.usuarios 
    ADD COLUMN IF NOT EXISTS sucursal_id BIGINT REFERENCES public.sucursales(id);

-- Agregar vinculación con Supabase Auth (para migración futura)
ALTER TABLE public.usuarios 
    ADD COLUMN IF NOT EXISTS auth_user_id UUID REFERENCES auth.users(id);

-- Agregar campos adicionales útiles
ALTER TABLE public.usuarios 
    ADD COLUMN IF NOT EXISTS activo BOOLEAN DEFAULT true,
    ADD COLUMN IF NOT EXISTS telefono TEXT,
    ADD COLUMN IF NOT EXISTS tipo_agente TEXT CHECK (tipo_agente IN ('in_house', 'home_office')),
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

COMMENT ON COLUMN public.usuarios.sucursal_id IS 'Sucursal asignada al usuario para segregación de datos';
COMMENT ON COLUMN public.usuarios.auth_user_id IS 'Vinculación con Supabase Auth (para migración)';
COMMENT ON COLUMN public.usuarios.tipo_agente IS 'Tipo de agente: in_house o home_office';

-- ----------------------------------------------------------------------------
-- 2.2 MODIFICAR TABLA ROLES (RF-01)
-- ----------------------------------------------------------------------------
ALTER TABLE public.roles 
    ADD COLUMN IF NOT EXISTS descripcion TEXT,
    ADD COLUMN IF NOT EXISTS permisos JSONB DEFAULT '{}',
    ADD COLUMN IF NOT EXISTS nivel INTEGER DEFAULT 0, -- Para jerarquía
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW();

-- Insertar roles según RF-01
INSERT INTO public.roles (nombre, descripcion, nivel) VALUES 
    ('director', 'Dirección General - Acceso total', 100),
    ('gerente', 'Gerente de Sucursal - Acceso a su sucursal', 80),
    ('ventas_inhouse', 'Agente de Ventas In-House', 50),
    ('ventas_homeoffice', 'Agente de Ventas Home Office', 50),
    ('contabilidad', 'Área de Contabilidad', 60),
    ('sistemas', 'Área de Sistemas', 90),
    ('admin', 'Administrador del Sistema', 95)
ON CONFLICT (nombre) DO UPDATE SET 
    descripcion = EXCLUDED.descripcion,
    nivel = EXCLUDED.nivel;

-- ----------------------------------------------------------------------------
-- 2.3 MODIFICAR TABLA EMPRESAS (RF-04, RF-08)
-- ----------------------------------------------------------------------------
ALTER TABLE public.empresas 
    ADD COLUMN IF NOT EXISTS tipo_cliente TEXT CHECK (tipo_cliente IN ('corporativo', 'gobierno', 'particular')) DEFAULT 'corporativo',
    ADD COLUMN IF NOT EXISTS rfc TEXT,
    ADD COLUMN IF NOT EXISTS razon_social TEXT,
    ADD COLUMN IF NOT EXISTS direccion_fiscal TEXT,
    ADD COLUMN IF NOT EXISTS contacto_nombre TEXT,
    ADD COLUMN IF NOT EXISTS contacto_email TEXT,
    ADD COLUMN IF NOT EXISTS contacto_telefono TEXT,
    
    -- Campos de crédito (RF-08)
    ADD COLUMN IF NOT EXISTS limite_credito NUMERIC(12,2) DEFAULT 0,
    ADD COLUMN IF NOT EXISTS credito_disponible NUMERIC(12,2) DEFAULT 0,
    ADD COLUMN IF NOT EXISTS dias_credito INTEGER DEFAULT 0,
    ADD COLUMN IF NOT EXISTS credito_activo BOOLEAN DEFAULT false,
    
    -- Especificaciones técnicas para licitaciones (RF-05) - JSONB como sugiere el documento
    ADD COLUMN IF NOT EXISTS especificaciones_tecnicas JSONB DEFAULT '{}',
    
    ADD COLUMN IF NOT EXISTS sucursal_id BIGINT REFERENCES public.sucursales(id),
    ADD COLUMN IF NOT EXISTS activa BOOLEAN DEFAULT true,
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

COMMENT ON COLUMN public.empresas.especificaciones_tecnicas IS 'Especificaciones técnicas de licitaciones en JSONB (RF-05). Ej: {"requiere_desglose_tua": true, "formato_factura": "cfdi40"}';
COMMENT ON COLUMN public.empresas.limite_credito IS 'Límite de crédito asignado a la empresa';
COMMENT ON COLUMN public.empresas.credito_disponible IS 'Crédito disponible actual (se actualiza con triggers)';

-- ----------------------------------------------------------------------------
-- 2.4 MODIFICAR TABLA DESGLOSES (RF-05, RF-07)
-- ----------------------------------------------------------------------------
ALTER TABLE public.desgloses 
    ADD COLUMN IF NOT EXISTS numero_boleto TEXT UNIQUE, -- RNF-05: Sin duplicados
    ADD COLUMN IF NOT EXISTS fecha_emision DATE DEFAULT CURRENT_DATE,
    ADD COLUMN IF NOT EXISTS fecha_viaje DATE,
    ADD COLUMN IF NOT EXISTS estatus TEXT CHECK (estatus IN ('pendiente', 'emitido', 'cancelado', 'reembolsado')) DEFAULT 'pendiente',
    ADD COLUMN IF NOT EXISTS pasajero_nombre TEXT,
    ADD COLUMN IF NOT EXISTS ruta TEXT, -- Ej: "TIJ-MEX-TIJ"
    ADD COLUMN IF NOT EXISTS clase TEXT, -- Económica, Ejecutiva, etc.
    ADD COLUMN IF NOT EXISTS sucursal_id BIGINT REFERENCES public.sucursales(id),
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

COMMENT ON COLUMN public.desgloses.numero_boleto IS 'Número de boleto único - RNF-05';
COMMENT ON COLUMN public.desgloses.estatus IS 'Estado del desglose: pendiente, emitido, cancelado, reembolsado';

-- Índice para búsqueda por número de boleto
CREATE UNIQUE INDEX IF NOT EXISTS idx_desgloses_numero_boleto ON public.desgloses(numero_boleto) WHERE numero_boleto IS NOT NULL;

-- ----------------------------------------------------------------------------
-- 2.5 MODIFICAR TABLA PAPELETAS (RF-06)
-- ----------------------------------------------------------------------------
-- Primero, agregar las nuevas columnas
ALTER TABLE public.papeletas 
    ADD COLUMN IF NOT EXISTS tarjeta_id BIGINT REFERENCES public.tarjetas_corporativas(id),
    ADD COLUMN IF NOT EXISTS desglose_folio BIGINT REFERENCES public.desgloses(folio),
    ADD COLUMN IF NOT EXISTS autorizacion_id BIGINT REFERENCES public.autorizaciones(id), -- Si requirió autorización
    ADD COLUMN IF NOT EXISTS conciliada BOOLEAN DEFAULT false,
    ADD COLUMN IF NOT EXISTS fecha_conciliacion DATE,
    ADD COLUMN IF NOT EXISTS sucursal_id BIGINT REFERENCES public.sucursales(id),
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

-- Renombrar 'tarjeta' a 'tarjeta_legacy' si existe (para migración gradual)
-- ALTER TABLE public.papeletas RENAME COLUMN tarjeta TO tarjeta_legacy;

-- El campo 'folio' ya existe como TEXT y debe ser UNIQUE
-- Agregar constraint si no existe
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM pg_constraint 
        WHERE conname = 'papeletas_folio_unique' AND conrelid = 'public.papeletas'::regclass
    ) THEN
        ALTER TABLE public.papeletas ADD CONSTRAINT papeletas_folio_unique UNIQUE (folio);
    END IF;
END $$;

COMMENT ON COLUMN public.papeletas.folio IS 'Número único de folio de papeleta (visible al crear) - RF-06';
COMMENT ON COLUMN public.papeletas.tarjeta_id IS 'Referencia a la tarjeta corporativa usada';
COMMENT ON COLUMN public.papeletas.autorizacion_id IS 'Referencia a la autorización si fue requerida (préstamo de tarjeta)';

-- ----------------------------------------------------------------------------
-- 2.6 MODIFICAR TABLA AEROLINEAS
-- ----------------------------------------------------------------------------
ALTER TABLE public.aerolineas 
    ADD COLUMN IF NOT EXISTS codigo_iata CHAR(2),
    ADD COLUMN IF NOT EXISTS codigo_icao CHAR(3),
    ADD COLUMN IF NOT EXISTS activa BOOLEAN DEFAULT true,
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW();

-- ----------------------------------------------------------------------------
-- 2.7 MODIFICAR TABLA CARGOS_SERVICIO (RF-04)
-- ----------------------------------------------------------------------------
ALTER TABLE public.cargos_servicio 
    ADD COLUMN IF NOT EXISTS descripcion TEXT,
    ADD COLUMN IF NOT EXISTS activo BOOLEAN DEFAULT true,
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();

-- Asegurar que 'tipo' tenga valores válidos
-- tipo: 'nacional', 'internacional', 'hotel', 'auto', 'otro'

-- ----------------------------------------------------------------------------
-- 2.8 MODIFICAR TABLA TARIFAS_FIJAS
-- ----------------------------------------------------------------------------
ALTER TABLE public.tarifas_fijas 
    ADD COLUMN IF NOT EXISTS tipo TEXT CHECK (tipo IN ('nacional', 'internacional', 'hotel', 'auto', 'otro')) DEFAULT 'nacional',
    ADD COLUMN IF NOT EXISTS descripcion TEXT,
    ADD COLUMN IF NOT EXISTS activa BOOLEAN DEFAULT true,
    ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ DEFAULT NOW(),
    ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ DEFAULT NOW();


-- ============================================================================
-- PARTE 3: FUNCIONES HELPER PARA RLS
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 3.1 Función para obtener el usuario actual desde auth.email()
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_current_usuario()
RETURNS public.usuarios AS $$
    SELECT * FROM public.usuarios WHERE correo = auth.email() LIMIT 1;
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- ----------------------------------------------------------------------------
-- 3.2 Función para obtener la sucursal del usuario actual
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_user_sucursal_id()
RETURNS BIGINT AS $$
    SELECT sucursal_id FROM public.usuarios WHERE correo = auth.email() LIMIT 1;
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- ----------------------------------------------------------------------------
-- 3.3 Función para obtener el rol del usuario actual
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_user_rol()
RETURNS TEXT AS $$
    SELECT rol FROM public.usuarios WHERE correo = auth.email() LIMIT 1;
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- ----------------------------------------------------------------------------
-- 3.4 Función para obtener el nivel de rol del usuario actual
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.get_user_rol_nivel()
RETURNS INTEGER AS $$
    SELECT COALESCE(r.nivel, 0)
    FROM public.usuarios u
    LEFT JOIN public.roles r ON u.rol = r.nombre
    WHERE u.correo = auth.email()
    LIMIT 1;
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- ----------------------------------------------------------------------------
-- 3.5 Función para verificar si el usuario es director/admin
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_admin_or_director()
RETURNS BOOLEAN AS $$
    SELECT EXISTS (
        SELECT 1 FROM public.usuarios 
        WHERE correo = auth.email() 
        AND rol IN ('admin', 'director', 'sistemas')
    );
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- ----------------------------------------------------------------------------
-- 3.6 Función para verificar si el usuario es gerente o superior
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.is_gerente_or_higher()
RETURNS BOOLEAN AS $$
    SELECT EXISTS (
        SELECT 1 FROM public.usuarios u
        JOIN public.roles r ON u.rol = r.nombre
        WHERE u.correo = auth.email() 
        AND r.nivel >= 80
    );
$$ LANGUAGE SQL SECURITY DEFINER STABLE;

-- ----------------------------------------------------------------------------
-- 3.7 Función para verificar acceso a sucursal
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.can_access_sucursal(p_sucursal_id BIGINT)
RETURNS BOOLEAN AS $$
    SELECT 
        -- Admins y directores ven todo
        public.is_admin_or_director()
        OR
        -- Usuarios normales solo ven su sucursal
        (SELECT sucursal_id FROM public.usuarios WHERE correo = auth.email()) = p_sucursal_id;
$$ LANGUAGE SQL SECURITY DEFINER STABLE;


-- ============================================================================
-- PARTE 4: RLS POLICIES CON SEGREGACIÓN POR SUCURSAL
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 4.1 RLS PARA SUCURSALES
-- ----------------------------------------------------------------------------
ALTER TABLE public.sucursales ENABLE ROW LEVEL SECURITY;

DROP POLICY IF EXISTS "sucursales_read_all" ON public.sucursales;
CREATE POLICY "sucursales_read_all" ON public.sucursales
    FOR SELECT USING (true); -- Todos pueden ver el catálogo de sucursales

DROP POLICY IF EXISTS "sucursales_modify_admin" ON public.sucursales;
CREATE POLICY "sucursales_modify_admin" ON public.sucursales
    FOR ALL USING (public.is_admin_or_director());

-- ----------------------------------------------------------------------------
-- 4.2 RLS PARA USUARIOS (Actualizado con sucursal)
-- ----------------------------------------------------------------------------
-- Eliminar policies existentes
DROP POLICY IF EXISTS "users_read_own_profile" ON public.usuarios;
DROP POLICY IF EXISTS "users_update_own_profile" ON public.usuarios;
DROP POLICY IF EXISTS "admins_read_all_users" ON public.usuarios;

-- Nuevas policies
CREATE POLICY "usuarios_read_own" ON public.usuarios
    FOR SELECT USING (correo = auth.email());

CREATE POLICY "usuarios_read_same_branch" ON public.usuarios
    FOR SELECT USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

CREATE POLICY "usuarios_read_all_admin" ON public.usuarios
    FOR SELECT USING (public.is_admin_or_director());

CREATE POLICY "usuarios_update_own" ON public.usuarios
    FOR UPDATE USING (correo = auth.email())
    WITH CHECK (correo = auth.email());

CREATE POLICY "usuarios_modify_admin" ON public.usuarios
    FOR ALL USING (public.is_admin_or_director());

-- ----------------------------------------------------------------------------
-- 4.3 RLS PARA EMPRESAS (Actualizado con sucursal)
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "authenticated_read_companies" ON public.empresas;
DROP POLICY IF EXISTS "authenticated_modify_companies" ON public.empresas;

CREATE POLICY "empresas_read_own_branch" ON public.empresas
    FOR SELECT USING (
        public.can_access_sucursal(sucursal_id)
        OR sucursal_id IS NULL -- Empresas sin sucursal asignada visibles para todos
    );

CREATE POLICY "empresas_modify_gerente" ON public.empresas
    FOR ALL USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- ----------------------------------------------------------------------------
-- 4.4 RLS PARA DESGLOSES (Actualizado con sucursal)
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "users_read_own_breakdowns" ON public.desgloses;
DROP POLICY IF EXISTS "users_create_own_breakdowns" ON public.desgloses;
DROP POLICY IF EXISTS "users_update_own_breakdowns" ON public.desgloses;
DROP POLICY IF EXISTS "users_delete_own_breakdowns" ON public.desgloses;

-- Agentes ven sus propios desgloses
CREATE POLICY "desgloses_read_own" ON public.desgloses
    FOR SELECT USING (
        usuario_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
    );

-- Gerentes ven desgloses de su sucursal
CREATE POLICY "desgloses_read_branch" ON public.desgloses
    FOR SELECT USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- Crear: usuarios autenticados en su sucursal
CREATE POLICY "desgloses_insert" ON public.desgloses
    FOR INSERT WITH CHECK (
        usuario_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
        AND sucursal_id = public.get_user_sucursal_id()
    );

-- Actualizar: solo propios o gerentes de la sucursal
CREATE POLICY "desgloses_update_own" ON public.desgloses
    FOR UPDATE USING (
        usuario_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
    );

CREATE POLICY "desgloses_update_gerente" ON public.desgloses
    FOR UPDATE USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- Eliminar: solo admin/director
CREATE POLICY "desgloses_delete_admin" ON public.desgloses
    FOR DELETE USING (public.is_admin_or_director());

-- ----------------------------------------------------------------------------
-- 4.5 RLS PARA PAPELETAS (Actualizado con sucursal)
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "users_read_own_tickets" ON public.papeletas;
DROP POLICY IF EXISTS "users_create_own_tickets" ON public.papeletas;
DROP POLICY IF EXISTS "users_update_own_tickets" ON public.papeletas;
DROP POLICY IF EXISTS "users_delete_own_tickets" ON public.papeletas;

-- Leer: propias o de la sucursal (para gerentes)
CREATE POLICY "papeletas_read_own" ON public.papeletas
    FOR SELECT USING (
        usuario_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
    );

CREATE POLICY "papeletas_read_branch" ON public.papeletas
    FOR SELECT USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- Crear: cualquier usuario autenticado puede crear (con autorización para tarjetas prestadas)
CREATE POLICY "papeletas_insert" ON public.papeletas
    FOR INSERT WITH CHECK (
        usuario_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
        AND sucursal_id = public.get_user_sucursal_id()
    );

-- Actualizar: propias o gerentes
CREATE POLICY "papeletas_update_own" ON public.papeletas
    FOR UPDATE USING (
        usuario_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
        AND conciliada = false -- No se pueden editar papeletas conciliadas
    );

CREATE POLICY "papeletas_update_gerente" ON public.papeletas
    FOR UPDATE USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- Eliminar: solo admin
CREATE POLICY "papeletas_delete_admin" ON public.papeletas
    FOR DELETE USING (public.is_admin_or_director());

-- ----------------------------------------------------------------------------
-- 4.6 RLS PARA TARJETAS CORPORATIVAS
-- ----------------------------------------------------------------------------
ALTER TABLE public.tarjetas_corporativas ENABLE ROW LEVEL SECURITY;

-- Todos los autenticados pueden ver tarjetas de su sucursal
CREATE POLICY "tarjetas_read_branch" ON public.tarjetas_corporativas
    FOR SELECT USING (
        public.can_access_sucursal(sucursal_id)
        OR sucursal_id IS NULL
    );

-- Solo gerentes y superiores pueden modificar
CREATE POLICY "tarjetas_modify_gerente" ON public.tarjetas_corporativas
    FOR ALL USING (public.is_gerente_or_higher());

-- ----------------------------------------------------------------------------
-- 4.7 RLS PARA AUTORIZACIONES
-- ----------------------------------------------------------------------------
ALTER TABLE public.autorizaciones ENABLE ROW LEVEL SECURITY;

-- Usuarios ven sus propias solicitudes
CREATE POLICY "autorizaciones_read_own" ON public.autorizaciones
    FOR SELECT USING (
        solicitante_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
    );

-- Gerentes ven solicitudes de su sucursal
CREATE POLICY "autorizaciones_read_branch" ON public.autorizaciones
    FOR SELECT USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- Cualquier usuario puede crear solicitudes
CREATE POLICY "autorizaciones_insert" ON public.autorizaciones
    FOR INSERT WITH CHECK (
        solicitante_id IN (SELECT id FROM public.usuarios WHERE correo = auth.email())
    );

-- Solo gerentes/directores pueden aprobar/rechazar
CREATE POLICY "autorizaciones_update_gerente" ON public.autorizaciones
    FOR UPDATE USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- ----------------------------------------------------------------------------
-- 4.8 RLS PARA COMPROBANTES DE PAGO
-- ----------------------------------------------------------------------------
ALTER TABLE public.comprobantes_pago ENABLE ROW LEVEL SECURITY;

CREATE POLICY "comprobantes_read_branch" ON public.comprobantes_pago
    FOR SELECT USING (public.can_access_sucursal(sucursal_id));

CREATE POLICY "comprobantes_insert_contabilidad" ON public.comprobantes_pago
    FOR INSERT WITH CHECK (
        public.get_user_rol() IN ('contabilidad', 'admin', 'director', 'gerente')
    );

CREATE POLICY "comprobantes_update_contabilidad" ON public.comprobantes_pago
    FOR UPDATE USING (
        public.get_user_rol() IN ('contabilidad', 'admin', 'director')
    );

-- ----------------------------------------------------------------------------
-- 4.9 RLS PARA CRÉDITOS MOVIMIENTOS
-- ----------------------------------------------------------------------------
ALTER TABLE public.creditos_movimientos ENABLE ROW LEVEL SECURITY;

CREATE POLICY "creditos_read_branch" ON public.creditos_movimientos
    FOR SELECT USING (
        public.is_gerente_or_higher()
        AND public.can_access_sucursal(sucursal_id)
    );

-- Solo contabilidad y admin pueden insertar
CREATE POLICY "creditos_insert" ON public.creditos_movimientos
    FOR INSERT WITH CHECK (
        public.get_user_rol() IN ('contabilidad', 'admin', 'director')
    );

-- ----------------------------------------------------------------------------
-- 4.10 RLS PARA AUDIT LOGS
-- ----------------------------------------------------------------------------
ALTER TABLE public.audit_logs ENABLE ROW LEVEL SECURITY;

-- Solo admin y sistemas pueden ver logs
CREATE POLICY "audit_read_admin" ON public.audit_logs
    FOR SELECT USING (
        public.get_user_rol() IN ('admin', 'sistemas', 'director')
    );

-- Nadie puede modificar logs directamente (solo triggers)
-- Los inserts se harán via SECURITY DEFINER functions

-- ----------------------------------------------------------------------------
-- 4.11 RLS PARA NOTIFICACIONES
-- ----------------------------------------------------------------------------
ALTER TABLE public.notificaciones ENABLE ROW LEVEL SECURITY;

CREATE POLICY "notificaciones_read_branch" ON public.notificaciones
    FOR SELECT USING (public.can_access_sucursal(sucursal_id));

-- Solo el sistema puede insertar (via functions)
CREATE POLICY "notificaciones_insert_system" ON public.notificaciones
    FOR INSERT WITH CHECK (public.get_user_rol() IN ('admin', 'sistemas'));

-- ----------------------------------------------------------------------------
-- 4.12 RLS PARA CARGOS_SERVICIO (Actualizado)
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "users_read_own_service_charges" ON public.cargos_servicio;
DROP POLICY IF EXISTS "users_create_own_service_charges" ON public.cargos_servicio;
DROP POLICY IF EXISTS "users_update_own_service_charges" ON public.cargos_servicio;
DROP POLICY IF EXISTS "users_delete_own_service_charges" ON public.cargos_servicio;

-- Todos los autenticados pueden leer cargos de servicio
CREATE POLICY "cargos_servicio_read_all" ON public.cargos_servicio
    FOR SELECT USING (true);

-- Solo gerentes y superiores pueden modificar
CREATE POLICY "cargos_servicio_modify_gerente" ON public.cargos_servicio
    FOR ALL USING (public.is_gerente_or_higher());

-- ----------------------------------------------------------------------------
-- 4.13 RLS PARA DESCUENTOS (Actualizado)
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "users_read_own_discounts" ON public.descuentos;
DROP POLICY IF EXISTS "users_create_own_discounts" ON public.descuentos;
DROP POLICY IF EXISTS "users_update_own_discounts" ON public.descuentos;
DROP POLICY IF EXISTS "users_delete_own_discounts" ON public.descuentos;

CREATE POLICY "descuentos_read_all" ON public.descuentos
    FOR SELECT USING (true);

CREATE POLICY "descuentos_modify_gerente" ON public.descuentos
    FOR ALL USING (public.is_gerente_or_higher());

-- ----------------------------------------------------------------------------
-- 4.14 RLS PARA TARIFAS_FIJAS (Actualizado)
-- ----------------------------------------------------------------------------
DROP POLICY IF EXISTS "public_read_rates" ON public.tarifas_fijas;
DROP POLICY IF EXISTS "authenticated_modify_rates" ON public.tarifas_fijas;

CREATE POLICY "tarifas_fijas_read_all" ON public.tarifas_fijas
    FOR SELECT USING (true);

CREATE POLICY "tarifas_fijas_modify_gerente" ON public.tarifas_fijas
    FOR ALL USING (public.is_gerente_or_higher());


-- ============================================================================
-- PARTE 5: TRIGGERS DE AUDITORÍA Y AUTOMATIZACIÓN
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 5.1 Función genérica de auditoría
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.audit_trigger_func()
RETURNS TRIGGER AS $$
DECLARE
    v_usuario_id BIGINT;
    v_usuario_email TEXT;
    v_sucursal_id BIGINT;
    v_old_data JSONB;
    v_new_data JSONB;
    v_changed_fields TEXT[];
BEGIN
    -- Obtener datos del usuario actual
    SELECT id, correo, sucursal_id 
    INTO v_usuario_id, v_usuario_email, v_sucursal_id
    FROM public.usuarios 
    WHERE correo = auth.email();

    -- Preparar datos según la operación
    IF TG_OP = 'DELETE' THEN
        v_old_data := to_jsonb(OLD);
        v_new_data := NULL;
        
        INSERT INTO public.audit_logs (
            tabla_nombre, registro_id, accion, 
            datos_anteriores, datos_nuevos,
            usuario_id, usuario_email, sucursal_id
        ) VALUES (
            TG_TABLE_NAME, OLD.id::TEXT, TG_OP,
            v_old_data, v_new_data,
            v_usuario_id, v_usuario_email, v_sucursal_id
        );
        RETURN OLD;
        
    ELSIF TG_OP = 'UPDATE' THEN
        v_old_data := to_jsonb(OLD);
        v_new_data := to_jsonb(NEW);
        
        -- Identificar campos modificados
        SELECT array_agg(key) INTO v_changed_fields
        FROM jsonb_each(v_new_data) 
        WHERE v_old_data->key IS DISTINCT FROM v_new_data->key;
        
        INSERT INTO public.audit_logs (
            tabla_nombre, registro_id, accion, 
            datos_anteriores, datos_nuevos, campos_modificados,
            usuario_id, usuario_email, sucursal_id
        ) VALUES (
            TG_TABLE_NAME, NEW.id::TEXT, TG_OP,
            v_old_data, v_new_data, v_changed_fields,
            v_usuario_id, v_usuario_email, v_sucursal_id
        );
        RETURN NEW;
        
    ELSIF TG_OP = 'INSERT' THEN
        v_old_data := NULL;
        v_new_data := to_jsonb(NEW);
        
        INSERT INTO public.audit_logs (
            tabla_nombre, registro_id, accion, 
            datos_anteriores, datos_nuevos,
            usuario_id, usuario_email, sucursal_id
        ) VALUES (
            TG_TABLE_NAME, NEW.id::TEXT, TG_OP,
            v_old_data, v_new_data,
            v_usuario_id, v_usuario_email, v_sucursal_id
        );
        RETURN NEW;
    END IF;
    
    RETURN NULL;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ----------------------------------------------------------------------------
-- 5.2 Aplicar triggers de auditoría a tablas críticas
-- ----------------------------------------------------------------------------
DROP TRIGGER IF EXISTS audit_usuarios ON public.usuarios;
CREATE TRIGGER audit_usuarios
    AFTER INSERT OR UPDATE OR DELETE ON public.usuarios
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func();

DROP TRIGGER IF EXISTS audit_empresas ON public.empresas;
CREATE TRIGGER audit_empresas
    AFTER INSERT OR UPDATE OR DELETE ON public.empresas
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func();

DROP TRIGGER IF EXISTS audit_desgloses ON public.desgloses;
CREATE TRIGGER audit_desgloses
    AFTER INSERT OR UPDATE OR DELETE ON public.desgloses
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func();

DROP TRIGGER IF EXISTS audit_papeletas ON public.papeletas;
CREATE TRIGGER audit_papeletas
    AFTER INSERT OR UPDATE OR DELETE ON public.papeletas
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func();

DROP TRIGGER IF EXISTS audit_autorizaciones ON public.autorizaciones;
CREATE TRIGGER audit_autorizaciones
    AFTER INSERT OR UPDATE OR DELETE ON public.autorizaciones
    FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_func();

-- ----------------------------------------------------------------------------
-- 5.3 Trigger para actualizar updated_at automáticamente
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar a todas las tablas con updated_at
DO $$
DECLARE
    t TEXT;
BEGIN
    FOR t IN 
        SELECT table_name 
        FROM information_schema.columns 
        WHERE table_schema = 'public' 
        AND column_name = 'updated_at'
    LOOP
        EXECUTE format('
            DROP TRIGGER IF EXISTS update_%I_updated_at ON public.%I;
            CREATE TRIGGER update_%I_updated_at
                BEFORE UPDATE ON public.%I
                FOR EACH ROW
                EXECUTE FUNCTION public.update_updated_at_column();
        ', t, t, t, t);
    END LOOP;
END $$;

-- ----------------------------------------------------------------------------
-- 5.4 Trigger para validar crédito antes de crear desglose (RF-08)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.validar_credito_empresa()
RETURNS TRIGGER AS $$
DECLARE
    v_credito_disponible NUMERIC;
    v_credito_activo BOOLEAN;
BEGIN
    -- Solo validar si la empresa tiene crédito activo
    SELECT credito_disponible, credito_activo 
    INTO v_credito_disponible, v_credito_activo
    FROM public.empresas 
    WHERE id = NEW.empresa_id;
    
    IF v_credito_activo AND NEW.total > v_credito_disponible THEN
        RAISE EXCEPTION 'Crédito insuficiente. Disponible: %, Requerido: %', 
            v_credito_disponible, NEW.total;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

DROP TRIGGER IF EXISTS validar_credito_desglose ON public.desgloses;
CREATE TRIGGER validar_credito_desglose
    BEFORE INSERT ON public.desgloses
    FOR EACH ROW
    EXECUTE FUNCTION public.validar_credito_empresa();

-- ----------------------------------------------------------------------------
-- 5.5 Trigger para actualizar crédito disponible al emitir desglose
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.actualizar_credito_empresa()
RETURNS TRIGGER AS $$
DECLARE
    v_credito_activo BOOLEAN;
    v_saldo_anterior NUMERIC;
    v_usuario_id BIGINT;
BEGIN
    -- Solo procesar si cambia a 'emitido'
    IF NEW.estatus = 'emitido' AND (OLD.estatus IS NULL OR OLD.estatus != 'emitido') THEN
        
        SELECT credito_activo, credito_disponible 
        INTO v_credito_activo, v_saldo_anterior
        FROM public.empresas 
        WHERE id = NEW.empresa_id;
        
        IF v_credito_activo THEN
            -- Descontar del crédito disponible
            UPDATE public.empresas 
            SET credito_disponible = credito_disponible - NEW.total
            WHERE id = NEW.empresa_id;
            
            -- Obtener usuario_id
            SELECT id INTO v_usuario_id 
            FROM public.usuarios WHERE correo = auth.email();
            
            -- Registrar movimiento
            INSERT INTO public.creditos_movimientos (
                empresa_id, tipo, monto, saldo_anterior, saldo_nuevo,
                desglose_folio, concepto, usuario_id, sucursal_id
            ) VALUES (
                NEW.empresa_id, 'cargo', NEW.total, v_saldo_anterior, 
                v_saldo_anterior - NEW.total, NEW.folio,
                'Emisión de boleto - Folio ' || NEW.folio,
                v_usuario_id, NEW.sucursal_id
            );
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS actualizar_credito_al_emitir ON public.desgloses;
CREATE TRIGGER actualizar_credito_al_emitir
    AFTER UPDATE ON public.desgloses
    FOR EACH ROW
    EXECUTE FUNCTION public.actualizar_credito_empresa();

-- ----------------------------------------------------------------------------
-- 5.6 Función para generar siguiente folio de papeleta (Secuencia por tarjeta)
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.generar_folio_papeleta(p_tarjeta_id BIGINT)
RETURNS TEXT AS $$
DECLARE
    v_numero_tarjeta TEXT;
    v_ultimo_folio INTEGER;
    v_nuevo_folio TEXT;
BEGIN
    -- Obtener número de tarjeta
    SELECT numero_tarjeta INTO v_numero_tarjeta
    FROM public.tarjetas_corporativas
    WHERE id = p_tarjeta_id;
    
    IF v_numero_tarjeta IS NULL THEN
        RAISE EXCEPTION 'Tarjeta no encontrada: %', p_tarjeta_id;
    END IF;
    
    -- Obtener último folio para esta tarjeta (formato: XXXX-0001)
    SELECT COALESCE(MAX(NULLIF(split_part(folio, '-', 2), '')::INTEGER), 0)
    INTO v_ultimo_folio
    FROM public.papeletas
    WHERE folio LIKE v_numero_tarjeta || '-%';
    
    -- Generar nuevo folio
    v_nuevo_folio := v_numero_tarjeta || '-' || LPAD((v_ultimo_folio + 1)::TEXT, 4, '0');
    
    RETURN v_nuevo_folio;
END;
$$ LANGUAGE plpgsql;

COMMENT ON FUNCTION public.generar_folio_papeleta IS 'Genera el siguiente folio de papeleta para una tarjeta. Formato: [NumTarjeta]-[Secuencial]';


-- ============================================================================
-- PARTE 6: VISTAS ÚTILES
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 6.1 Vista de resumen de crédito por empresa
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.v_credito_empresas AS
SELECT 
    e.id,
    e.nombre_empresa,
    e.tipo_cliente,
    e.limite_credito,
    e.credito_disponible,
    e.limite_credito - e.credito_disponible AS credito_utilizado,
    CASE 
        WHEN e.limite_credito > 0 
        THEN ROUND(((e.limite_credito - e.credito_disponible) / e.limite_credito * 100), 2)
        ELSE 0 
    END AS porcentaje_utilizado,
    e.dias_credito,
    e.credito_activo,
    s.nombre AS sucursal
FROM public.empresas e
LEFT JOIN public.sucursales s ON e.sucursal_id = s.id
WHERE e.credito_activo = true;

-- ----------------------------------------------------------------------------
-- 6.2 Vista de papeletas pendientes de conciliar
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.v_papeletas_pendientes AS
SELECT 
    p.id,
    p.folio,
    tc.nombre_tarjeta,
    tc.numero_tarjeta,
    p.fecha_venta,
    p.total,
    p.facturar_a,
    u.nombre AS agente,
    s.nombre AS sucursal,
    p.created_at
FROM public.papeletas p
JOIN public.tarjetas_corporativas tc ON p.tarjeta_id = tc.id
JOIN public.usuarios u ON p.usuario_id = u.id
LEFT JOIN public.sucursales s ON p.sucursal_id = s.id
WHERE p.conciliada = false
ORDER BY p.fecha_venta DESC;

-- ----------------------------------------------------------------------------
-- 6.3 Vista de autorizaciones pendientes
-- ----------------------------------------------------------------------------
CREATE OR REPLACE VIEW public.v_autorizaciones_pendientes AS
SELECT 
    a.id,
    a.tipo,
    a.motivo,
    a.monto_solicitado,
    a.fecha_solicitud,
    u_sol.nombre AS solicitante,
    tc.nombre_tarjeta,
    e.nombre_empresa,
    s.nombre AS sucursal
FROM public.autorizaciones a
JOIN public.usuarios u_sol ON a.solicitante_id = u_sol.id
LEFT JOIN public.tarjetas_corporativas tc ON a.tarjeta_id = tc.id
LEFT JOIN public.empresas e ON a.empresa_id = e.id
LEFT JOIN public.sucursales s ON a.sucursal_id = s.id
WHERE a.estatus = 'pendiente'
ORDER BY a.fecha_solicitud ASC;


-- ============================================================================
-- PARTE 7: GRANTS Y PERMISOS FINALES
-- ============================================================================

-- Dar permisos al rol authenticated de Supabase
GRANT USAGE ON SCHEMA public TO authenticated;
GRANT ALL ON ALL TABLES IN SCHEMA public TO authenticated;
GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO authenticated;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO authenticated;

-- Permisos para rol anon (solo lectura en catálogos)
GRANT USAGE ON SCHEMA public TO anon;
GRANT SELECT ON public.sucursales TO anon;
GRANT SELECT ON public.aerolineas TO anon;
GRANT SELECT ON public.roles TO anon;


-- ============================================================================
-- FIN DEL SCRIPT DE MIGRACIÓN
-- ============================================================================

-- NOTAS POST-MIGRACIÓN:
-- 1. Ejecutar UPDATE para asignar sucursal_id a usuarios existentes
-- 2. Ejecutar UPDATE para asignar sucursal_id a empresas existentes
-- 3. Migrar datos de la columna 'tarjeta' a la nueva tabla tarjetas_corporativas
-- 4. Configurar webhook de Google Chat para notificaciones
-- 5. Revisar y ajustar límites de crédito de empresas existentes